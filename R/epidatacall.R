#' An abstraction that holds information needed to make an epidata request
#' @rdname epidata_call
#' @aliases epidata_call
#'
#' @description
#' `epidata_call` objects are generated by endpoint functions like [`covidcast`];
#'  should be piped into a `fetch_*` function to fetch and
#' format the data:
#' - `fetch_tbl`: fetches the data, formats as a [`tibble::tibble`]
#' - `fetch_classic`: fetches the data in "classic" format: a list with three
#'    elements:
#'    - `"epidata"`: some R object (typically a `data.frame`) holding the data,
#'      if the request was successful
#'    - `"message"`: string; either `"success"` or some error/warning message
#'    - `"result"`: integer; either 1 or some error/warning code
#' - `fetch_csv`: fetches the data, formats as a string containing CSV data,
#'    with a special class `"epidata_csv"` added to prevent accidentally
#'    printing a huge number of lines
#' - `fetch_json`: fetches the data in JSON format then converts to a `data.frame`
#'
#' `create_epidata_call` is the constructor for `epidata_call` objects, but you
#' should not need to use it directly; instead, use an endpoint function, e.g.,
#' [`covidcast`], to generate an `epidata_call` for the data of interest.
#'
#' There are some other functions available for debugging and advanced usage:
#' - `request_url` (for debugging):  outputs the request URL from which data
#'    would be fetched (note additional parameters below)
#' - `with_base_url` (advanced): outputs an `epidata_call` that requests data
#'    from a different Epidata server
#'
#' @examples
#' covidcast(
#'   data_source = "jhu-csse",
#'   signals = "confirmed_7dav_incidence_prop",
#'   time_type = "day",
#'   geo_type = "state",
#'   time_values = epirange(20200601, 20200801),
#'   geo_values = c("ca", "fl")
#' ) %>% fetch_tbl
#'
#' @param endpoint the epidata endpoint to call
#' @param params the parameters to pass to the epidata endpoint
#' @param meta meta data to attach to the epidata call
#' @param only_supports_classic if true only classic format is supported
#'
#' @return
#' - For `create_epidata_call`: an `epidata_call` object
#'
create_epidata_call <- function(endpoint, params, meta = NULL,
                                only_supports_classic = FALSE) {
  stopifnot(is.character(endpoint), length(endpoint) == 1)
  stopifnot(is.list(params))
  stopifnot(is.null(meta) || is.list(meta))
  stopifnot(is.logical(only_supports_classic), length(only_supports_classic) == 1)
  if (is.null(meta)) {
    meta <- list()
  }
  structure(
    list(
      endpoint = endpoint,
      params = params,
      base_url = global_base_url,
      meta = meta,
      only_supports_classic = only_supports_classic
    ),
    class = "epidata_call"
  )
}

request_arguments <-
  function(epidata_call, format_type, fields = NULL) {
    stopifnot(inherits(epidata_call, "epidata_call"))
    stopifnot(format_type %in% c("json", "csv", "classic"))
    stopifnot(is.null(fields) || is.character(fields))

    extra_params <- list()
    if (format_type != "classic") {
      extra_params[["format"]] <- format_type
    }
    if (!is.null(fields)) {
      extra_params[["fields"]] <- fields
    }
    all_params <- c(epidata_call$params, extra_params)

    formatted_params <- list()
    for (name in names(all_params)) {
      v <- all_params[[name]]
      if (!is.null(v)) {
        formatted_params[[name]] <- format_list(v)
      }
    }
    formatted_params
  }

#' @export
print.epidata_call <- function(epidata_call) {
  stopifnot(inherits(epidata_call, "epidata_call"))
  cli::cli_h1("<epidata_call> object:")
  cli::cli_bullets(c(
    "*" = "Use fetch_classic, fetch_json, or fetch_csv to actually fetch the data",
    "*" = paste0("Request URL: ", request_url(epidata_call))
  ))
}

#' Fetches the data and returns a tibble
#' @rdname epidata_call
#'
#' @param epidata_call an instance of `epidata_call`
#' @param fields filter fields
#' @param disable_date_parsing disable automatic date parsing
#' @importFrom readr read_csv
#' @importFrom httr stop_for_status content
#' @importFrom rlang abort
#' @return
#' - For `fetch_tbl`: a [`tibble::tibble`]
#'
#' @export
fetch_tbl <- function(epidata_call, fields = NULL, disable_date_parsing = FALSE) {
  stopifnot(inherits(epidata_call, "epidata_call"))
  stopifnot(is.null(fields) || is.character(fields))
  stopifnot(is.logical(disable_date_parsing), length(disable_date_parsing) == 1)
  if (epidata_call$only_supports_classic) {
    rlang::abort("the endpoint only supports the classic message format, due to a non-standard behavior",
      epidata_call = epidata_call,
      class = "only_supports_classic_format"
    )
  }
  r <- fetch_csv(epidata_call, fields)
  meta <- epidata_call$meta
  fields_pred <- fields_to_predicate(fields)
  col_names <- c()
  col_types <- list()
  for (i in seq_len(length(meta))) {
    info <- meta[[i]]
    if (fields_pred(info$name)) {
      col_names <- c(col_names, info$name)
      col_types[info$name] <- info_to_type(info, disable_date_parsing)
    }
  }
  tbl <- if (length(col_names) > 0) {
    readr::read_csv(r, col_types = col_types)
  } else {
    readr::read_csv(r)
  }


  if (!disable_date_parsing) {
    # parse weeks
    columns <- colnames(tbl)
    for (i in seq_len(length(meta))) {
      info <- meta[[i]]
      if (info$name %in% columns && info$type == "epiweek") {
        tbl[[info$name]] <- parse_api_week(tbl[[info$name]])
      }
    }
  }
  tbl
}

#' Fetches the data and returns the classic format
#' @rdname epidata_call
#'
#' @param epidata_call an instance of `epidata_call`
#' @param fields filter fields
#' @param disable_date_parsing disable automatic date parsing
#' @importFrom httr stop_for_status content http_error
#' @importFrom jsonlite fromJSON
#' @return
#' - For `fetch_classic`: the "classic" 3-element list format (see above)
#'
#' @export
fetch_classic <- function(epidata_call, fields = NULL, disable_date_parsing = FALSE) {
  stopifnot(inherits(epidata_call, "epidata_call"))
  stopifnot(is.null(fields) || is.character(fields))
  stopifnot(is.logical(disable_date_parsing), length(disable_date_parsing) == 1)
  res <- request_impl(epidata_call, "classic", fields)
  r <- httr::content(res, "text", encoding = "UTF-8")
  if (httr::http_error(res)) {
    # return message in case of error
    return(list(result = 0, message = paste0("error: ", r), epidata = data.frame()))
  }

  m <- jsonlite::fromJSON(r)
  if ("epidata" %in% names(m) && !(epidata_call$only_supports_classic)) {
    m$epidata <- parse_data_frame(epidata_call, m$epidata, disable_date_parsing = disable_date_parsing)
  }
  m
}

#' Fetches the data and returns the CSV text
#' @rdname epidata_call
#'
#' @param epidata_call an instance of `epidata_call`
#' @param fields filter fields
#' @importFrom httr stop_for_status content
#' @importFrom rlang abort
#' @return
#' - For `fetch_csv`: a string containing CSV text, with the `"epidata_csv"` class added
#'
#' @export
fetch_csv <- function(epidata_call, fields = NULL) {
  stopifnot(inherits(epidata_call, "epidata_call"))
  stopifnot(is.null(fields) || is.character(fields))
  if (epidata_call$only_supports_classic) {
    rlang::abort("the endpoint only supports the classic message format, due to a non-standard behavior",
      epidata_call = epidata_call,
      class = "only_supports_classic_format"
    )
  }
  res <- request_impl(epidata_call, "csv", fields)
  httr::stop_for_status(res)
  data <- httr::content(res, "text", encoding = "UTF-8")
  class(data) <- c("epidata_csv", class(data))
  data
}

#' Fetches the data in JSON format, then converts into an R object
#' @rdname epidata_call
#'
#' @param epidata_call an instance of `epidata_call`
#' @param fields filter fields
#' @param disable_date_parsing disable automatic date parsing
#' @importFrom httr stop_for_status content
#' @importFrom jsonlite fromJSON
#' @importFrom rlang abort
#' @return
#' - For `fetch_json`: a `data.frame` form of the object from the parsed JSON
#'   response
#'
#' @export
fetch_json <- function(epidata_call, fields = NULL, disable_date_parsing = FALSE) {
  stopifnot(inherits(epidata_call, "epidata_call"))
  stopifnot(is.null(fields) || is.character(fields))
  stopifnot(is.logical(disable_date_parsing), length(disable_date_parsing) == 1)
  if (epidata_call$only_supports_classic) {
    rlang::abort("the endpoint only supports the classic message format, due to a non-standard behavior",
      epidata_call = epidata_call,
      class = "only_supports_classic_format"
    )
  }
  res <- request_impl(epidata_call, "json", fields)
  httr::stop_for_status(res)
  r <- httr::content(res, "text", encoding = "UTF-8")
  parse_data_frame(epidata_call, jsonlite::fromJSON(r), disable_date_parsing = disable_date_parsing)
}

full_url <- function(epidata_call) {
  stopifnot(inherits(epidata_call, "epidata_call"))
  join_url(epidata_call$base_url, epidata_call$endpoint)
}

#' Returns the full request url for the given epidata_call
#' @rdname epidata_call
#'
#' @param epidata_call an instance of `epidata_call`
#' @param format_type format to return one of classic,json,csv
#' @param fields filter fields
#' @importFrom httr modify_url
#' @return
#' - For `request_url`: a string containing the URL
#'
#' @export
request_url <- function(epidata_call, format_type = "classic", fields = NULL) {
  stopifnot(inherits(epidata_call, "epidata_call"))
  url <- full_url(epidata_call)
  params <- request_arguments(epidata_call, format_type, fields)
  httr::modify_url(url, query = params)
}

#' `epidata_call` object using a different base URL
#' @rdname epidata_call
#'
#' @param epidata_call an instance of `epidata_call`
#' @param base_url base URL to use
#' @return
#' - For `with_base_url`: another `epidata_call` object
#'
#' @export
with_base_url <- function(epidata_call, base_url) {
  stopifnot(inherits(epidata_call, "epidata_call"))
  stopifnot(is.character(base_url), length(base_url) == 1)
  epidata_call$base_url <- base_url
  epidata_call
}

request_impl <- function(epidata_call, format_type, fields = NULL) {
  stopifnot(inherits(epidata_call, "epidata_call"))
  stopifnot(format_type %in% c("json", "csv", "classic"))
  # API call
  url <- full_url(epidata_call)
  params <- request_arguments(epidata_call, format_type, fields)

  do_request(url, params)
}

#' @export
print.epidata_csv <- function(x, ...) {
  char_limit <- getOption("epidata_csv__char_limit", default = 300L)
  cat(
    "# A epidata_csv object with", nchar(x), "characters; showing up to", char_limit,
    "characters below. To print the entire string, use `print(as.character(x))`:\n"
  )
  cat(substr(x, 1L, char_limit))
  if (nchar(x) > char_limit) {
    cat("[...]")
  }
  cat("\n")
  invisible(x)
}

info_to_type <- function(info, disable_date_parsing = FALSE) {
  types <- list(
    date = if (disable_date_parsing) {
      readr::col_integer()
    } else {
      readr::col_date(format = "%Y%m%d")
    },
    epiweek = readr::col_integer(),
    bool = readr::col_logical(),
    text = readr::col_character(),
    int = readr::col_integer(),
    float = readr::col_double(),
    categorical = readr::col_factor(info$categories, TRUE)
  )
  r <- types[info$type]
  stopifnot(!is.null(r))
  r
}
